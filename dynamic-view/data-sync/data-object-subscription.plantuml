

@startuml "data-object-subscribe.png"

autonumber

!define SHOW_SP1
!define SHOW_SMAtSP1

!define SHOW_SP2
!define SHOW_SMAtSP2

!define SHOW_RuntimeA

!define SHOW_CoreRuntimeA
!define SHOW_SMAtRuntimeA
!define SHOW_SP1SandboxAtRuntimeA
!define SHOW_Syncher1AtRuntimeA

!define SHOW_Runtime1B

!define SHOW_CoreRuntime1B
!define SHOW_SMAtRuntime1B
!define SHOW_SP1SandboxAtRuntime1B
!define SHOW_Syncher1AtRuntime1B

!include ../runtime_objects.plantuml


== listeners are added on Observer side ==

Sync1@1B -> Sync1@1B : Minibus.Addlisteners(\nDataObjURL\changes,\nSyncherListener)

== check if this is the resume of a data stream sync ==

Sync1@1B -> RunSM@1B : Read Msg

RunSM@1B -> RunSM@1B : are there stored\n subscribed data objects


alt yes, it is the resume of a data sync stream

	alt
		Sync1@1B <-- RunSM@1B : temporary response with local stored objects
	end

== lets get the most updated version ==

	RunSM@1B -> Sync1@A : Read Msg

	RunSM@1B <-- Sync1@A : Read Response Msg with most updated Data Object

	Sync1@1B <-- RunSM@1B : final response with most updated stored objects


	note right
		FFS: At this point The subscribe message is not sent to sync manager
		since it is assumed it has already added the required listeners
		when it was instantiated by the RuntimeUA
		But we should further study whether it is better to resume subscriptions
		at sync manager only when demanded by syncher.
		In this way it is ensured listeners are already added at the minibus
		when updates reach the syncher sandbox.
		However, since the runtime is connected to MN as soon as the Hyperty is
		registered, it is not ensured updates won't reach the msg bus before
		the minibus listeners are added.
		note: for inter-domain resume of subscriptions, the deployment of the
		foreigner MN stub was already performed by the READ message sent in step 3
	end note

else no, this object is not stored locally. We have to subscribe it.

	Sync1@1B <-- RunSM@1B : response no subscriptions found

	Sync1@1B -> RunSM@1B : Subscribe Msg

	alt subscribed object is to be stored localy

		RunSM@1B -> RunSM@1B : bus.addListener(\nDataObjURL\changes URL, \nSyncManagerListener)

	end

		RunSM@1B -> RunSM@1B : bus.addListener(\nDataObjURL\changes URL, \nObserverSandboxListener)

		RunSM@1B -> RunSM@1B : registry.getP2PStubSandbox(\nDataObjURL)

		alt : No p2p Stub available
			== Set Routing Path at Observer Msg Node ==

			RunSM@1B -> SM@SP2 : Subscribe Msg

			SM@SP2 -> SM@SP2 : add Listeners

			RunSM@1B <- SM@SP2 : OK Subscribe Response Msg

			== Set Routing Path at Reporter Msg Node ==

			RunSM@1B -> SM@SP1 : Subscribe Msg

			SM@SP1 -> SM@SP1 : add Listeners

			RunSM@1B <- SM@SP1 : OK Subscribe Response Msg

		end

		== Requests Reporter Sync Manager to Subscribe ==

		RunSM@1B -> RunSM@A : Subscribe Msg

		RunSM@A <- RunSM@A :	check subscriber\n has been already authorised

		opt Authorisation policies requires to check data object is registered

			RunSM@A -> RunSM@A : registry.\ndiscoverDataObject(\n DataObj URL )

		end

		RunSM@A -> RunSM@A : bus.addListener(\nDataObjURL\changes URL\n, listener)

		note right
			Listeners of new observers are added into message bus,
			 to receive updates about changes in the data object
		end note

		opt
			RunSM@A -> RunSM@A : bus.postMessage(\n Update Message\nfor DataObjectObservers )

			note right
				the DataObjectObservers resource is updated
				with information about the new Hyperty observer
				thus, if Hyperty owner is listening on this resource
				it will be informed about the new Observer.
			end note

		end

		RunSM@A -> RunSM@A : registry\n.p2pConnetion(message)

		note right
			registry checks if message was sent via a P2P Stub and if yes it adds its originator into the corresponding P2P Connection entry
		end note

		RunSM@A -> RunSM@1B : OK Subscribe\nResponse Message

	== Observer Side Sync Manager confirms Subscription ==

	Sync1@1B <- RunSM@1B : Subscribe Response Msg \n w/ Data Objs

end

newpage

== Object is Updated ==

Sync1@A -> RunSM@A : Update Message

Sync1@A -> Sync1@1B : Update Message


@enduml
